# -*- coding: utf-8 -*-

from sumoscheduler import SumoScheduler
from sumoscheduler import Duration as dur 
import os
import pandas as pd 
import numpy as np
import datetime
import time 

def create_policy_dict(a_dict):
    """
    This is a function to create the required dictionary for the policy space. 

    Parameters
    ----------
    a_dict : dictionary
        keys: (string) sumo encode variables
        values: (list) their corresponding values' lists 
        example: 
        {"Sumo__Plant__CSTR2__param__DOSP":[0], 
         "Sumo__Plant__CSTR3__param__DOSP":[0,0.5],
         "Sumo__Plant__CSTR4__param__DOSP":[0,0.5]}

    Returns
    -------
    policy_dict: (nested dictionary)
        keys: (int) starting from 0 
        values: (dictionary) 
            keys: (string) sumo encode variables 
            values: (numeric type: int/float) the value of sumo encode variables
   example: 
        {
        0: {'Sumo__Plant__CSTR2__param__DOSP': 0,
             'Sumo__Plant__CSTR3__param__DOSP': 0,
             'Sumo__Plant__CSTR4__param__DOSP': 0},
        1: {'Sumo__Plant__CSTR2__param__DOSP': 0,
            'Sumo__Plant__CSTR3__param__DOSP': 0,
            'Sumo__Plant__CSTR4__param__DOSP': 0.5},
        2: {'Sumo__Plant__CSTR2__param__DOSP': 0,
            'Sumo__Plant__CSTR3__param__DOSP': 0.5,
            'Sumo__Plant__CSTR4__param__DOSP': 0},
        3: {'Sumo__Plant__CSTR2__param__DOSP': 0,
            'Sumo__Plant__CSTR3__param__DOSP': 0.5,
            'Sumo__Plant__CSTR4__param__DOSP': 0.5} 
        }
    """
    
    if not isinstance(a_dict, dict):
        raise TypeError("The input should be a dictionary whose keys are sumo_encode names and values are lists of the their corresponding values")
    else:
        policy_dict = {}
        name_list=list(a_dict.keys())
        import itertools
        policy_space = list(itertools.product(*list(a_dict.values())))
        for policyID, an_op in enumerate(policy_space):
            temp_dict = {}
            for i in range(len(name_list)):
                temp_dict[name_list[i]] = an_op[i]
            policy_dict[policyID] = temp_dict
    return policy_dict





class CY_SUMO():
    """
    This is a module/wrapper to run SUMO21 simulations by directly interacting 
    sumocore.dll, which is on the SUMO-Python API (sumoscheduler.py) provided
    by Dynatita. It is able to replicate major functions in SUMO GUI.  
      
    Author: Cheng Yang, Unversitiy of Michigan, Ann Arbor, MI 
    
    Inputs:
    --------------
    (Mandatory)
        `model`: str  
        The 'XXX.dll' file generated by the SUMO GUI, e.g. "sumocore.dll".
        Full path is needed if python scripts and 'XXX.dll' are not located 
        under the same path, e.g.   "C:/Users/28417/sumocore.dll" 
            
        `sumo_variables`: list
        The sumo encode variables to track in the ouputs,
        which can be found in the .xml file  
        e.g.  ["Sumo__Time",
               "Sumo__Plant__Effluent1__SNHx",
               "Sumo__Plant__CSTR2__DOSP",
               "Sumo__Plant__CSTR3__DOSP",
               "Sumo__Plant__CSTR4__DOSP"]
           
        `param_dic`: dictionary (could be nested dictionary)  
        The (nested) dictionary that stores the different combinations of   
        parameters to adjust in the simulation. 
        e.g. {"set1":{'Sumo__Plant__CSTR3__param__DOSP': 2,
                      'Sumo__Plant__Influent__param__Q':24000}
              "set2":{'Sumo__Plant__CSTR3__param__DOSP': 1,
                      'Sumo__Plant__Influent__param__Q':12000}}     
        
        
        
    (Optional)

        `parallel_job`: int, default = 4 
        Number of cores in CPU that can be run in parallel 
        
        `default_xml`: string, default = None 
        Name of the 'XXX.xml' loaded in advance for simulation
        
        `param_dic`: dictionary, nested
        Parameters to change in simulations.
        e.g. 
            {'trial1':{'Sumo__Plant__CSTR3__param__DOSP': 2,
                        'Sumo__Plant__Influent__param__Q':24000},
             'trial2':{'Sumo__Plant__CSTR3__param__DOSP': 1.5,
                         'Sumo__Plant__Influent__param__Q':26000}}
        
        
    Attributes: - Only important attributes are listed, attributes not mentioned 
                  here are for internal use.
    --------------
        All inputs, both mandatory and optional 
        
        `SS_table`: pd.DataFrame()
        --The output from parallel steady-state simulations 
    
    
    Methods: - Only important methods are listed, methods not mentioned 
                  here are for internal use.
    --------------
        `steady_state()`: run multiple steady state simulations

    Examples: 
        please refer to https://github.com/ChengYangUmich/CY_SUMO/examples
    --------------
    """
    def __init__(self, 
                 model, 
                 sumo_variables, 
                 paralell_job = 4,
                 default_xml = None,
                 param_dic = None):
        self.model = model
        self.sumo_variables = sumo_variables
        self.paralell_job = paralell_job
        self.default_xml = default_xml
        self.param_dic = param_dic
        self._param_commands_dic = {} # predefined, converted from self.param_dic
        # Intermediate variable for extracting current values of state variables
        # in SUMO
        if param_dic == None:
            self.current_sumo_vars = {1:None}
        else:
            # Create an empty nested diction for intermediate data storage
            self.current_sumo_vars = {key:None for key in range(1,len(param_dic)+1)}   
            # Add variable names from the param_dic into sumo_variables
            for a_dic in self.param_dic.values():
                for a_var in a_dic.keys():
                    self.sumo_variables.append(a_var)
        
    def _set_up_scheduler(self, msg_callback, datacomm_callback):
        """
        (Internal) method
    
        Used for creating a SumoScheduler Object. One console is only allow 
        to create one SumoScheduler object
        
        Parameters:
        --------------   
        `msg_callback`: function
            The message callback function used for SumoScheduler registration
        `datacomm_callback`: function
            The data commnunication callback function used for SumoScheduler registration
            
        """
        self.sumo = SumoScheduler()
        self.sumo.setParallelJobs(self.paralell_job)
        self.sumo.message_callback = msg_callback
        self.sumo.datacomm_callback = datacomm_callback
    
    def _line_command(self, a_dict, default_xml= None):
        """
        (Internal) Method, used to create a one-line commands seperated with ';'
        from an initial condition dictionary that could be input into the SUMO
        Parameters
        ----------
        a_dict : dictionary
            a dictionary that stores the parameters to be adjusted
            e.g. {'Sumo__Plant__CSTR3__param__DOSP': 2,
                  'Sumo__Plant__Influent__param__Q':24000}

        Returns
        -------
        commands : string 
            a string that combines all items from the a_dict and formats them 
            into a online standard SUMO input command
            e.g. "reset;mode steady;set Sumo__Plant__CSTR3__param__DOSP 2; 
                  set Sumo__Plant__Influent__param__Q 24000;start;"
        """
        # If not .xml file is given, reset and start simulations
        if default_xml == None:
            commands = "reset;"
        # If .xml file is given, load .xml file, map to initial condition and then start 
        else:
            commands = f"load {self.current_xml};maptoic;"
        commands += "mode steady;"
        # append ajusted variables into the one-line command string 
        for a_key, a_val in a_dict.items():
            commands += f"set {a_key} {a_val};"
            commands += "start;"
        return commands
   
    def _set_ss_commands(self):
        """
        (Internal) Method, used to create a list of commands used for 
        steady-state simulations, and stored it in self._param_commands_dic
            e.g. "reset;mode steady;set Sumo__Plant__CSTR3__param__DOSP 2; 
                  set Sumo__Plant__Influent__param__Q 24000;start;" --> 
                  ["reset","mode steady",
                   "set Sumo__Plant__CSTR3__param__DOSP 2",
                   "set Sumo__Plant__Influent__param__Q 24000",
                   "start"]
        """
        if self.param_dic == None:
            self._param_commands_dic[0] = 'reset;mode steady;start'
        # if `self.param_dic` is a nested diction
        elif any(isinstance(i,dict) for i in self.param_dic.values()):            
            for a_dic_key,a_dic in self.param_dic.items():
                self._param_commands_dic[a_dic_key] = self._line_command(a_dic)
        else:
            self._param_commands_dic[0] = self._line_command(self.param_dic)
    
    # Code blokc for replicating steady-state simulations
    def steady_state(self, save_table = True, 
                     save_name = "steady_state_result.xlsx", save_xml = False):
        """
        Parameters
        ----------
        save_table : Boolean, optional  
            Whether to save the self.ss_table
        save_name : String, optional 
            The ouput xlsx file name saved from the self.ss_table
        save_xml: Boolean, optional
            Whether to save the .xml files for each steady state simulations

        Returns
        -------
        None. examples see --> .\examples\steadyStateSimulation.py

        """
        # Pre-define variables to store steady-state simulation results 
        self.SS_table = pd.DataFrame()
        # An intermediate boolean used in steady_state_msg_callback 
        self._save_xml = save_xml
        # Create the steady-state commands in lists 
        self._set_ss_commands()
        # Register callback functions 
        msg_callback = self._steady_state_msg_callback
        datacomm_callback = self._steady_state_datacomm_callback
        self._set_up_scheduler(msg_callback, datacomm_callback)
        for a_key, a_line_command in self._param_commands_dic.items():
            commands = []
            for a_element in a_line_command.split(";"):
                if a_element != "":
                    commands.append(a_element + ";")              
            self.sumo.schedule(
                model = self.model,
                commands = commands,
                variables = self.sumo_variables,
                jobData ={"SS_cmd": a_line_command,
                          "Cmd_ID": a_key})
        print("Jobs started:", self.sumo.scheduledJobs)
        
        while (self.sumo.scheduledJobs > 0):
            time.sleep(0.1)

        self.sumo.scheduler.cleanup()
        
        if save_table == True:
            self.SS_table.to_excel(save_name)
            print(f"------SS_table saved as {save_name}-----")
    
            
    def _steady_state_msg_callback(self,job,msg):
        """
        (Internal) method
        Parameters
        ----------
        job : Int
            The job ID defined in the sumo scheduler
        msg : string 
            Message similar to the sumo core window 

        Returns
        -------
        None.

        """
        print(f"#{job} {msg}")
        if (self.sumo.isSimFinishedMsg(msg)):
            ## save the .xml files
            if self._save_xml == True:
                jobData = self.sumo.getJobData(job)
                xml_file = f"Cmd_ID_{jobData['Cmd_ID']}.xml"
                command = f"save {xml_file};"
                self.sumo.sendCommand(job,command)
                print(f"{xml_file} -------- saved-----------")
            self.SS_table = self.SS_table.append(self.current_sumo_vars[job],ignore_index = True)
            self.sumo.finish(job)
    
    def _steady_state_datacomm_callback(self,job,data):
        """
        (Internal) method
        Parameters
        ----------
        job : Int
            The job ID defined in the sumo scheduler
        data : dictionary 
            Stored information defined in the self.sumo.schedule() - jobData 

        Returns
        -------
        None.

        """
        jobData = self.sumo.getJobData(job)
        self.current_sumo_vars[job] = {**data,**jobData}
        